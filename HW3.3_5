def get_platform(useragent):
    platforms = ['Android',
                 'BlackBerry',
                 'Windows NT',
                 'iPad',
                 'iPhone',
                 'iPod',
                 'Linux',
                 'Macintosh',
                 'PLAYSTATION 3']
    platform = False
    for x in platforms:
        if x.lower() in useragent.lower():
                platform = x
    if not platform:
        platform = 'Other'
    return platform
#creating a dict of dicts with outer key= "by" 
#input 'number' 'info interested in' 'by: field'

#build outer dict key
#need a dictionary of outer keys and outer values
args= "5,platform,country_code"
number, info, by = args.split(',')

outerkeydict={'timestamp':0,'platform':1,'referring_url':2,'short_url_cname':3,'long_url':4,
    'geo_city_name':5, 'country_code':6, 'geo_region':7,'accept_language':8, 'timezone':9}

outer_dict={}
for line in open('bitly_2.tsv').readlines()[1:]:
    els = line.split('\t')
    if info == 'platform':
        new = get_platform(els[outerkeydict[info]])
    else:
        new = els[outerkeydict[info]]
    outer_list = []
    outer_list.append(new)
    if by == 'platform':
        outerkey = get_platform(els[outerkeydict[by]])
    else:
        outerkey = els[outerkeydict[by]]
    if outerkey in outer_dict:
        # append the new value to the existing key
        outer_dict[outerkey].append(outer_list)
    else:
        # create a new key
        outer_dict[outerkey]=outer_list
    #find way to do the same for inner dict
from collections import Iterable    
def flatten(lis):
     for item in lis:
         if isinstance(item, Iterable) and not isinstance(item, basestring):
             for x in flatten(item):
                 yield x
         else:        
             yield item
valueset={}
valueset2 = {}             
for key, value in outer_dict.items():
    for i in key:
        value = list(flatten(value))
        valueset[key] = set(value)
        valueset2[key] = value

combined_dict = {}
for k, v in valueset2.iteritems():
    combined_dict[k] = dict((i, v.count(i)) for i in v)
    
#get the top __ for each key in dict

def sort_innerval(a_dict):
    to_sort=a_dict.items()
    x= range(len(to_sort))
    for i in x:
        sortedtups=zip(to_sort[i][1].keys(), sorted(to_sort[i][1].values(), reverse=True))
        print "{0}: {1}".format(to_sort[i][0], sortedtups[:int(number)])

sort_innerval(combined_dict)



    
